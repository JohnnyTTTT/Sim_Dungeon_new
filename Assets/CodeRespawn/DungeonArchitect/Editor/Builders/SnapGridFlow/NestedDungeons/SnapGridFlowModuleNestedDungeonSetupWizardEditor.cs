//$ Copyright 2015-25, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//

using System;
using System.Numerics;
using DungeonArchitect.Flow.Impl.SnapGridFlow.Components;
using DungeonArchitect.Builders.SnapGridFlow.NestedDungeons;
using UnityEditor;
using UnityEngine;
using Quaternion = UnityEngine.Quaternion;
using Vector3 = UnityEngine.Vector3;

namespace DungeonArchitect.Editors.SGF.NestedDungeons
{
    [CustomEditor(typeof(SnapGridFlowModuleNestedDungeonSetupWizard))]
    public class SnapGridFlowModuleNestedDungeonSetupWizardEditor : Editor
    {
        public override void OnInspectorGUI()
        {
            DrawDefaultInspector();
        
            SnapGridFlowModuleNestedDungeonSetupWizard generator = (SnapGridFlowModuleNestedDungeonSetupWizard)target;
        
            if(GUILayout.Button("Setup Chunk Template"))
            {
                GeneratePrefab();
            }
        }

        void GeneratePrefab()
        {
            var config = target as SnapGridFlowModuleNestedDungeonSetupWizard;
            if (config == null) return;
            var nestedDungeon = config.gameObject.GetComponentInChildren<Dungeon>();
            if (nestedDungeon == null)
            {
                EditorUtility.DisplayDialog("Error", "Missing dungeon, you should place one as a child of this object.", "OK");
                return;
            }
            if (config.snapConnectionPrefab == null)
            {
                EditorUtility.DisplayDialog("Error", "Snap connection prefab is not set.", "OK");
                return;
            }

            var sgfModule = config.GetComponent<SnapGridFlowModule>();
            if (sgfModule == null)
            {
                EditorUtility.DisplayDialog("Error", "SnapGridFlowModule script missing, please attach it to this game object", "OK");
                return;
            }

            var numChunks = sgfModule.numChunks;
            var moduleBounds = sgfModule.moduleBounds;
            if (moduleBounds == null)
            {
                EditorUtility.DisplayDialog("Error", "Snap module bounds is not assigned to the SnapGridFlowModule script", "OK");
                return;
            }

            if (config.autoGenRoot != null)
            {
                DestroyImmediate(config.autoGenRoot);
            }

            var roomSetupScript = config.GetComponent<SnapGridFlowModuleNestedDungeonController>();
            if (roomSetupScript == null)
            {
                roomSetupScript = config.gameObject.AddComponent<SnapGridFlowModuleNestedDungeonController>();
            }
            roomSetupScript.moduleDungeon = nestedDungeon;
            
            var autoGenRoot = new GameObject("_AutoGenerated");
            autoGenRoot.transform.SetParent(config.transform);

            config.autoGenRoot = autoGenRoot;

            var nestedDungeonObject = nestedDungeon.gameObject;
            var chunkSize = moduleBounds.chunkSize;
            if (config.centerDungeonActor)
            {
                nestedDungeonObject.transform.localPosition = Vector3.Scale(numChunks, chunkSize) * 0.5f;
            }

            if (config.createNegationVolume)
            {
                var negationVolumeObject = new GameObject("NegationVolume");
                negationVolumeObject.transform.SetParent(autoGenRoot.transform);

                var negationVolumeSize = Vector3.Scale(chunkSize, numChunks +  new Vector3(0, 1, 0));
                negationVolumeObject.transform.localScale = negationVolumeSize;
                
                var negationVolumeLoc = Vector3.Scale(chunkSize, numChunks) / 2;
                negationVolumeLoc.y = chunkSize.y * (numChunks.y / 2.0f - 0.5f);
                negationVolumeObject.transform.localPosition = negationVolumeLoc;
                
                var negationVolume = negationVolumeObject.AddComponent<NegationVolume>();
                negationVolume.inverse = true;
                negationVolume.autoBuildOnMove = false;
                negationVolume.dungeon = nestedDungeon;
            }

            var chunkItems = new GameObject("Chunk Items");
            chunkItems.isStatic = true;
            chunkItems.transform.SetParent(autoGenRoot.transform);
            var nestedDungeonSceneProvider = nestedDungeonObject.GetComponent<DungeonSceneProvider>();
            if (nestedDungeonSceneProvider == null)
            {
                EditorUtility.DisplayDialog("Error", "Invalid nested dungeon prefab.", "OK");
                return;
            }

            nestedDungeonSceneProvider.itemParent = chunkItems;

            var connectionsRoot = new GameObject("Connections");
            connectionsRoot.transform.SetParent(autoGenRoot.transform);

            void CreateConnectionObject(string connectionPrefix, float angleY, Vector3 location, Vector3Int intLocation)
            {
                var connectionName = string.Format("ConnectionParent_{0}_{1}_{2}_{3}", connectionPrefix, intLocation.x, intLocation.y, intLocation.z);
                var connectionHost = new GameObject(connectionName);
                connectionHost.transform.localPosition = location;
                connectionHost.transform.localRotation = Quaternion.Euler(0, angleY, 0);
                connectionHost.transform.SetParent(connectionsRoot.transform);

                var connection = PrefabUtility.InstantiatePrefab(config.snapConnectionPrefab, connectionHost.transform) as GameObject;
            }

            for (int x = 0; x < numChunks.x; x++)
            {
                for (int y = 0; y < numChunks.y; y++)
                {
                    var coord0 = Vector3.Scale(new Vector3(x + 0.5f, y, 0), chunkSize) + new Vector3(0, moduleBounds.doorOffsetY, 0);
                    var coord1 = Vector3.Scale(new Vector3(x + 0.5f, y, numChunks.z), chunkSize) + new Vector3(0, moduleBounds.doorOffsetY, 0);
                    CreateConnectionObject("X", 180, coord0, new Vector3Int(x, y, 0));
                    CreateConnectionObject("X", 0, coord1, new Vector3Int(x, y, numChunks.z));
                }
            }
            
            for (int z = 0; z < numChunks.z; z++)
            {
                for (int y = 0; y < numChunks.y; y++)
                {
                    var coord0 = Vector3.Scale(new Vector3(0, y, z + 0.5f), chunkSize) + new Vector3(0, moduleBounds.doorOffsetY, 0);
                    var coord1 = Vector3.Scale(new Vector3(numChunks.x, y, z + 0.5f), chunkSize) + new Vector3(0, moduleBounds.doorOffsetY, 0);
                    CreateConnectionObject("Y", 270, coord0, new Vector3Int(0, y, z));
                    CreateConnectionObject("Y", 90, coord1, new Vector3Int(numChunks.x, y, z));
                }
            }
        }
    }
}
